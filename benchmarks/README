!!!WORK IN PROGRESS!!!
!!!WORK IN PROGRESS!!!
!!!WORK IN PROGRESS!!!

GCC works. <del> But Clang has some problems. ¯\_(ツ)_/¯ </del>
Clang works!

========== ping-pong ==========

`ping` is a client.
`pong` is a server.

Usage:
pong <port> <threads> <blocksize> <sessions>
ping <port> <threads> <blocksize> <sessions> <timeout(s)>

Example:
./build/pong 8848 5 16384 50
./build/ping 8848 5 16384 50 10

One-click script:
* xmake: `xmake build benchmarks && xmake run benchmarks`.
* make: `make benchmark_script`.
It is recommended to use **xmake** to run benchmarks.
All commands should be run from the root directory.

Note:
* `pong_asio` is also a server, but it uses Asio. You can use it to compare performance.
  For a fair comparison, make sure to enable the `-DASIO_HAS_IO_URING` and `-DASIO_DISABLE_EPOLL` macros.
  (`epoll` is toooo fast! For the current kernel implementation, `io_uring` can't beat it.)
  Use `xmake run benchmarks --server asio` to benchmark.
* `ping_when_any` is also a client, but it uses `exec::when_any`. You can use it to compare polling performance.
  Although `uring_exec` supports per-I/O-operation cancellation, it may reduce performance.
  Use `xmake run benchmarks --client when_any` to benchmark.

Here is my benchmark report on:
* {Linux v6.4.8}
* {AMD 5800H, 16 GB}
* {uring_exec 7249ab3, asio 62481a2}
* {gcc v13.2.0 -O3}

blocksize       = 16384
timeout         = 10s
throughput unit = GiB/s

| threads / sessions | asio (io_uring) | uring_exec |
| ------------------ | --------------- | ---------- |
| 2 / 10             | 1.896           | 3.394      |
| 2 / 100            | 2.972           | 3.344      |
| 2 / 1000           | 1.365           | 2.052      |
| 4 / 10             | 1.821           | 3.217      |
| 4 / 100            | 2.737           | 3.456      |
| 4 / 1000           | 1.355           | 2.327      |
| 8 / 10             | 1.000           | 2.651      |
| 8 / 100            | 2.233           | 2.716      |
| 8 / 1000           | 1.217           | 4.768      |
